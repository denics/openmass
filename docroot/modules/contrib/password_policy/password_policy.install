<?php

/**
 * @file
 * Install, update and uninstall functions for the password_policy module.
 */

use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;

/**
 * Implements hook_install().
 */
function password_policy_install() {
  // Load all of the user accounts and put them in a queue to generate the
  // initial field values. This prevents timeouts when there are large numbers
  // of users. This also resolves the issues when importing settings using
  // configuration management reported in https://www.drupal.org/node/2771129.
  /** @var \Drupal\user\UserInterface[] $users */
  $user_uids = \Drupal::entityQuery('user')
    ->condition('uid', 0, '<>')
    ->execute();
  /** @var \Drupal\Core\Queue\QueueInterface $queue */
  $queue = \Drupal::service('queue')
    ->get('password_policy_reset_user');
  foreach ($user_uids as $uid) {
    $queue->createItem(['uid' => $uid]);
  }

  // Define the default values for the fields.
  $fields = [
    'field_last_password_reset' => [
      'field' => [
        'label' => t('Password Expiration'),
        'description' => t('The password will expire based on the number of days defined in the policy'),
        'default_value' => [
          [
            'default_date_type' => 'now',
            'default_date' => 'now',
          ],
        ],
        'settings' => [
          'on_label' => t('Expired Password'),
          'off_label' => t('Non-expired Password'),
        ],
      ],
      'field_storage' => [
        'type' => 'datetime',
        'settings' => [
          'datetime_type' => 'datetime',
        ],
        'module' => 'datetime',
      ],
    ],
    'field_password_expiration' => [
      'field' => [
        'label' => t('Last Password Reset'),
        'default_value' => [
          [
            'value' => 0,
          ],
        ],
        'settings' => [
          'on_label' => t('Expired Password'),
          'off_label' => t('Non-expired Password'),
        ],
      ],
      'field_storage' => [
        'type' => 'boolean',
        'settings' => [],
        'module' => 'boolean',
      ],
    ],
  ];

  // Loop through the fields and recreate them if necessary. This will guarantee
  // the fields exist prior to attempting to update the values on all of the
  // user accounts in the system.
  foreach ($fields as $field_name => $field_settings) {
    $field_config = [
      'field_name' => $field_name,
      'entity_type' => 'user',
      'bundle' => 'user',
    ];
    $field_config = array_merge($field_config, $field_settings['field']);
    $field_storage_config = [
      'id' => 'user.' . $field_name,
      'field_name' => $field_name,
      'entity_type' => 'user',
      'locked' => TRUE,
      'cardinality' => 1,
      'translatable' => TRUE,
      'indexes' => [],
      'persist_with_no_fields' => FALSE,
      'custom_storage' => FALSE,
    ];
    $field_storage_config = array_merge($field_storage_config, $field_settings['field_storage']);
    $field_storage = FieldStorageConfig::loadByName('user', $field_name);
    $field = FieldConfig::loadByName('user', 'user', $field_name);
    if (empty($field_storage)) {
      $field_storage = FieldStorageConfig::create($field_storage_config);
      $field_storage->save();
    }
    if (empty($field)) {
      // Setup the field configuration options.
      $field_config['field_storage'] = $field_storage;
      // Create the field against the user entity.
      $field = FieldConfig::create($field_config);
      $field->save();
    }
  }

}

/**
 * Implements hook_uninstall().
 */
function password_policy_uninstall() {
  // Load the fields on user entities and filter them by the fields provided by
  // Password Policy and remove them before uninstalling the module.
  $password_fieldnames = [
    'field_last_password_reset',
    'field_password_expiration',
  ];
  $fields = \Drupal::service('entity_field.manager')
    ->getFieldDefinitions('user', 'user');
  $filtered_fields = array_filter(
    $fields, function ($field_definition) {
    return $field_definition instanceof FieldConfig;
  }
  );
  foreach ($password_fieldnames as $password_fieldname) {
    // Prevent errors if the field has already been removed in some other way.
    if (isset($filtered_fields[$password_fieldname])) {
      $filtered_fields[$password_fieldname]->delete();
    }
  }

  // Also delete any pending queued items if any remain.
  /** @var \Drupal\Core\Queue\QueueInterface $queue */
  $queue = \Drupal::service('queue')
    ->get('password_policy_reset_user');
  $queue->deleteQueue();
}

/**
 * Implements hook_update_N().
 *
 * Add cron threshold to prevent memory overloads.
 */
function password_policy_update_8201() {
  $config = \Drupal::service('config.factory')->getEditable('password_policy.settings');

// Set and save new message value.
  $config->set('cron_threshold', '250')->save();
}
